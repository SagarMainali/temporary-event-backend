const User = require("../models/userModel");
const { generateHashedPassword, comparePassword, generateToken, verifyToken, throwError, handleSuccessResponse, handleErrorResponse } = require("../utils/utils");
const { senderEmailAddress, transporter } = require("../config/nodemailer");
const validator = require("validator");

// register new user/event organizer
const registerUser = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    console.log("Incoming request for registering new user:\n", req.body);

    if (!username || !email || !password) {
      throwError(400, "Required: ssername, email & password")
    }
    if (!validator.isEmail(email)) {
      throwError(400, "Invalid format: email")
    }
    if (password.length < 8) {
      throwError(400, "Password must be at least 8 characters")
    }

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      throwError(409, "Email already registered")
    }

    const hashPassword = await generateHashedPassword(password);

    User.create({
      username,
      email,
      password: hashPassword,
    });

    handleSuccessResponse(res, 201, "Successfully registered user")
  } catch (error) {
    handleErrorResponse(res, error)
  }
};

// login user and send accessToken to response
const loginUser = async (req, res) => {
  try {
    const { email, password: userPassword } = req.body;

    if (!email || !userPassword) {
      throwError(400, "Required: email & password")
    }

    const user = await User.findOne({ email });
    if (!user) {
      throwError(404, "User not registered")
    }

    const isPasswordMatch = await comparePassword(userPassword, user.password);
    if (!isPasswordMatch) {
      throwError(401, "Incorrect Password")
    }

    const accessToken = generateToken(user._id, process.env.JWT_SECRET_ACCESS, "15m");
    const refreshToken = generateToken(user._id, process.env.JWT_SECRET_REFRESH, "7d");

    const cookieConfig = {
      httpOnly: true,
      secure: true,
      sameSite: 'none',
      path: '/',
      maxAge: 7 * 24 * 60 * 60 * 1000
    }

    res.cookie('access_token', accessToken, cookieConfig);
    res.cookie('refresh_token', refreshToken, cookieConfig);

    handleSuccessResponse(res, 200, "Successfully logged in")
  } catch (error) {
    handleErrorResponse(res, error)
  }
};

// verify access token to acknowledge user auth state
const checkAuthState = async (_, res) => {
  // the middleware already verifies the user authentication
  handleSuccessResponse(res, 200, "User authenticated")
};

// logout user by clearing tokens stored in cookies
const logoutUser = async (_, res) => {
  const cookieConfig = {
    httpOnly: true,
    secure: true,
    sameSite: "none",
    path: '/',
  }

  // clear both cookies
  res.clearCookie("access_token", cookieConfig);
  res.clearCookie("refresh_token", cookieConfig);

  handleSuccessResponse(res, 200, "Successfully logged out")
}

// send reset-password-url in email to user
const forgotPassword = async (req, res) => {
  const { email } = req.body;

  try {
    if (!email) {
      throwError(400, "Required: email")
    }

    const user = await User.findOne({ email });

    if (!user) {
      throwError(404, "User not found")
    }

    const resetToken = generateToken(user._id, process.env.JWT_SECRET_ACCESS, "5m");

    if (!resetToken) {
      throwError(500, "Failed to generate reset token")
    }

    const resetUrl = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`;

    const mailOptions = {
      to: email,
      from: senderEmailAddress,
      subject: "Reset Password",
      text: `You requested a password reset. Click the link below to reset your password: \n\n${resetUrl}`,
      html: `<p>You requested a password reset. Click the link below to reset your password:</p><a href="${resetUrl}">Reset Password</a>`,
    };

    const response = await transporter.sendMail(mailOptions);
    console.log("Password reset email sent:", response);

    handleSuccessResponse(res, 200, "Successfully sent password reset email")
  } catch (error) {
    handleErrorResponse(res, error)
  }
};

// reset password api, this api is used alongside forgot-password api
// call this aip with the new access token generated by forgotPassword api
const resetPassword = async (req, res) => {
  const userId = req.user.id;
  const { newPassword } = req.body;

  try {
    if (!newPassword) {
      throwError(400, "Required: newPassword")
    }

    const user = await User.findById(userId);
    if (!user) {
      throwError(404, "User not found")
    }

    const hashedPassword = await generateHashedPassword(newPassword);

    user.password = hashedPassword;
    await user.save();

    handleSuccessResponse(res, 200, "Successfully reset password")
  } catch (error) {
    handleErrorResponse(res, error)
  }
};

// update password
const changePassword = async (req, res) => {
  const userId = req.user.id;
  const { oldPassword, newPassword } = req.body;

  try {
    if (!oldPassword || !newPassword) {
      throwError(400, "Required: oldPassword & newPassword")
    }

    const user = await User.findById(userId);
    if (!user) {
      throwError(404, "User not found")
    }

    const isMatch = await comparePassword(oldPassword, user.password);
    if (!isMatch) {
      throwError(400, "Incorrect old password")
    }

    const hashedPassword = await generateHashedPassword(newPassword);

    user.password = hashedPassword;
    await user.save();

    handleSuccessResponse(res, 200, "Successfully updated password")
  } catch (error) {
    handleErrorResponse(res, error)
  }
};

// generate new access token
const refreshAccessToken = async (req, res) => {
  const errorMessage = "Invalid refresh token!";

  try {
    const refreshToken = req.cookies.refresh_token;
    if (!refreshToken) {
      throwError(403, errorMessage)
    }

    // verify refresh token
    const result = verifyToken(refreshToken, process.env.JWT_SECRET_REFRESH);
    if (!result?.valid) {
      // If the token is invalid or expired, handle the error (e.g., return 401)
      throwError(result.statusCode, result.errorMessage)
    }

    const userId = result.payload.id;

    const newAccessToken = generateToken(userId, process.env.JWT_SECRET_ACCESS, "15m");

    res.cookie("access_token", newAccessToken, {
      httpOnly: true,
      secure: true,
      sameSite: "none",
      path: '/',
      maxAge: 7 * 24 * 60 * 60 * 1000,
    });

    handleSuccessResponse(res, 200, "Successfully refreshed access token")
  } catch (error) {
    handleErrorResponse(res, error)
  }
};

module.exports = {
  registerUser,
  loginUser,
  checkAuthState,
  logoutUser,
  forgotPassword,
  resetPassword,
  changePassword,
  refreshAccessToken
};
